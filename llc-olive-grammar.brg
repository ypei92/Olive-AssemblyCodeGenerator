%{
/*
   FILE: sample4.brg
  
   Copyright (c) 1997 Princeton University

   All rights reserved.

   This software is to be used for non-commercial purposes only,
   unless authorized permission to do otherwise is obtained.  
   For more information, contact spam@ee.princeton.edu
*/

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <llvm/IR/Instruction.h>
#include <llvm/IR/Instructions.h>
//#include "/home1/04012/ypei/llvm/include/llvm/IR/Instruction.h"
//#include "/home1/04012/ypei/llvm/include/llvm/IR/Instructions.h"

enum {
    CALL=54,
    RET=1,
	ADD=11,
    MERGE=997,
    LOAD=30,
    STORE=31,
    IMM=996,
    ARG=998,
    OFFSET=999,
    ARGEND=995
};

static char ArgRegs[6][6] = {"%%rdi", "%%rsi", "%%rdx", "%%rcx", "%%r8", "%%r9"};
static char CalleeRegs[5][6] = {"%%rbx", "%%r12", "%%r13", "%%r14", "%%r15"};
static char CallerRegs[2][6] = {"%%r10", "%%r11"};
static char Regs[13][6] = {"%%rdi", "%%rsi", "%%rdx", "%%rcx", "%%r8", "%%r9", "%%rbx", "%%r12", "%%r13", "%%r14", "%%r15", "%%r10", "%%r11"}; 

enum {
    RDI = 0,
    RSI = 1,
    RDX = 2,
    RCX = 3,
    R8  = 4,
    R9  = 5,
    RBX = 6,
    R12 = 7,
    R13 = 8,
    R14 = 9,
    R15 = 10,
    R10 = 11,
    R11 = 12
};

typedef struct tree {
	int op;
	struct tree *kids[2];
	int val;
    llvm::Instruction *I;
    int valtype;
	struct { struct burm_state *state; } x;
} *NODEPTR, *Tree;

#define GET_KIDS(p)	((p)->kids)
#define PANIC printf
#define STATE_LABEL(p) ((p)->x.state)
#define SET_STATE(p,s) (p)->x.state=(s)
#define DEFAULT_COST	break
#define NO_ACTION(x)

typedef struct COST {
    int cost;
} COST;
#define COST_LESS(a,b) ((a).cost < (b).cost)
static COST COST_INFINITY = { 32767 };
static COST COST_ZERO     = { 0 };

enum {
    reG=0,
    meM=1,
    imM=2,
    arglisT=3,
    pointeR=4,
    nontypE = 999
};

typedef struct LoadedMem {
    char* UnderFunName;
    int Offset;
    int TargetReg;
    struct LoadedMem *next;
} LoadedMem;

static LoadedMem *LoadedMemHead = NULL;
LoadedMem* findLoadedMem(char* name, int off, int tarreg) {
    LoadedMem *p = LoadedMemHead;
    while(p != NULL) {
        if( p->UnderFunName == name || p->Offset == off || p->TargetReg == tarreg )
            return p;
        p = p->next;
    }

	LoadedMem *lmem = (LoadedMem*) malloc(sizeof(LoadedMem));

    lmem -> UnderFunName = name;
    lmem -> Offset = off;
    lmem -> TargetReg = tarreg;
    
    if( LoadedMemHead != NULL )
        lmem -> next = LoadedMemHead -> next;
    else 
        lmem -> next = NULL;

    LoadedMemHead = lmem;
    return lmem;
}

/*static char* burm_string = "FOO";*/
static int _ern = 0;

static int shouldTrace = 0;
static int shouldCover = 0;
static int RegCounter = 1;
static llvm::Function* PreFun = NULL;

int OP_LABEL(NODEPTR p) {
    if(p) printf(" p->op%d \n", p->op);
	switch (p->op) {
	    //case IMM:  if (p->val == 0) return ZERO;
        case CALL: return 1;
        case RET: return 2; 
        case ADD: return 3;
        case MERGE: return 4;
        case LOAD: return 5;
        case STORE: return 6;
        case IMM: return 7;
        case ARG: return 8;
        case OFFSET: return 9;
        case ARGEND: return 10;
	    default: return p->op;
	}
    
}

static void burm_trace(NODEPTR, int, COST);

%}
%term BURP=0 CALL=54 RET=1 ADD=11 MERGE=997 LOAD=30 STORE=31
%term IMM=996 ARG=998 OFFSET=999 ARGEND=995
%declare<void> stmt<int indent>;
%declare<void> reg<int indent>;
%declare<void> mem<int indent>;
%declare<void> imm<int indent>;
%declare<void> arglist<int indent>;
%declare<void> argend<int indent>;
%%

stmt:	BURP(_,_,_)
	{ return 1; }
	= {
		$immed[2,stmt](10);
	};

stmt:   reg
    { $cost[0].cost=$cost[1].cost; }
    = {
        llvm::Function* CurFun = $0->I->getFunction();
        if( CurFun != PreFun ) {
            PreFun = CurFun;
            RegCounter = 1;
            printf("_Your_%s:\n",CurFun->getName());
            printf("    pushq %%rbp\n");
            printf("    movq %%rsp, %%rbp\n");
        }
        $action[1](0);
    };

stmt:   mem
    { $cost[0].cost=$cost[1].cost; }
    = {
        llvm::Function* CurFun = $0->I->getFunction();
        if( CurFun != PreFun ) {
            PreFun = CurFun;
            RegCounter = 1;
            printf("_Your_%s:\n",CurFun->getName());
            printf("    pushq %%rbp\n");
            printf("    movq %%rsp, %%rbp\n");
        }
        $action[1](0);
    };

reg:    RET(imm)
    { $cost[0].cost=$cost[2].cost+1;}
    = {
        $action[2](0);
        printf("    mov $%d, %%rax\n", $2->val);
        printf("    mov %%rbp, %%rsp\n");
        printf("    pop %%rbp\n");
        printf("    ret\n");

        $0->val = $2->val;
        $0->valtype = imM;
    };

reg:    RET(reg)
    { $cost[0].cost=$cost[2].cost+1;}
    = {
        $action[2](0);
        printf("    mov %%%d, %%rax\n", $2->val);
        printf("    mov %%rbp, %%rsp\n");
        printf("    pop %%rbp\n");
        printf("    ret\n");

        $0->val = $2->val;
        $0->valtype = reG;
    };

reg:    RET(mem)
    { $cost[0].cost=$cost[2].cost+1;}
    = {
        $action[2](0);
        printf("    mov %d(%%rbp), %%rax\n", $2->val);
        printf("    mov %%rbp, %%rsp\n");
        printf("    pop %%rbp\n");
        printf("    ret\n");

        $0->val = $2->val;
        $0->valtype = meM;
    };

reg:    CALL(arglist)
    { $cost[0].cost=$cost[2].cost+1; }
    = {
        printf("just in CALL%d\n", $0->val);
        if( $0->val != 0 )
            $action[2](0);

        unsigned int NumOperands = $0->I->getNumOperands();
        llvm::Value* FunValue = $0->I->getOperand(NumOperands - 1);
        //char* FunName = FunValue -> getName();

        printf("    call %s\n", FunValue -> getName());
        printf("    movq %%rax, %%%d\n", RegCounter );

        $0->val = RegCounter++;
        $0->valtype = reG;
    };

reg:    ADD(reg, reg)
    { $cost[0].cost=$cost[2].cost+$cost[3].cost+1; }
    = {
        $action[2](0);
        $action[3](0);

        printf("    addq %%%d, %%%d\n", $2->val, $3->val);

        $0->val = $3->val;
        $0->valtype = reG;
    };


reg:    ADD(imm, reg)
    { $cost[0].cost=$cost[2].cost+$cost[3].cost+1; }
    = {
        $action[2](0);
        $action[3](0);

        printf("    addq $%d, %%%d\n", $2->val, $3->val);

        $0->val = $3->val;
        $0->valtype = reG;
    };

reg:    ADD(mem, reg)
    { $cost[0].cost=$cost[2].cost+$cost[3].cost+1; }
    = {
        $action[2](0);
        $action[3](0);

        printf("    addq %d(%%rbp), %%%d\n", $2->val, $3->val);

        $0->val = $3->val;
        $0->valtype = reG;
    };

reg:    ADD(LOAD(mem), reg)
    { $cost[0].cost=$cost[3].cost+$cost[4].cost+1; }
    = {
        $action[3](0);
        $action[4](0);

        printf("    addq %d(%%rbp), %%%d\n", $3->val, $4->val);

        $0->val = $4->val;
        $0->valtype = reG;
    };

reg:    LOAD(reg)
    { $cost[0].cost=$cost[2].cost+1; }
    = {
        $action[2](0);

        printf("    movq %%%d, %%%d\n", $2->val, RegCounter);

        $0->val = RegCounter++;
        $0->valtype = reG;
    };

reg:    LOAD(mem)
    { $cost[0].cost=$cost[2].cost+1; }
    = {
        $action[2](0);
        //LoadedMem* findLoadedMem(char* name, int off, int tarreg)
        printf("    movq %d(%%rbp), %%%d\n", $2->val, RegCounter);

        $0->val = RegCounter++;
        $0->valtype = reG;
    };

reg:    LOAD(LOAD(mem))
    { $cost[0].cost=$cost[3].cost+1; }
    = {
        $action[3](0);

        printf("    movq %d(%%rbp), %%%d\n", $3->val, RegCounter);

        $0->val = RegCounter++;
        $0->valtype = reG;
    };

reg:    LOAD(LOAD(LOAD(mem)))
    { $cost[0].cost=$cost[4].cost+1; }
    = {
        $action[4](0);

        printf("    movq %d(%%rbp), %%%d\n", $4->val, RegCounter);

        $0->val = RegCounter++;
        $0->valtype = reG;
    };

reg:    ARG
    { $cost[0].cost = 0; }
    = {
        $0->val = RegCounter++;
    };

mem:    ADD(reg, mem)
    { $cost[0].cost=$cost[2].cost+$cost[3].cost+1; }
    = {
        $action[2](0);
        $action[3](0);

        printf("    addq %%%d, %d(%%rbp)\n", $2->val, $3->val);

        $0->val = $3->val;
        $0->valtype = meM;
    };

mem:    ADD(reg, LOAD(mem))
    { $cost[0].cost=$cost[2].cost+$cost[4].cost+1; }
    = {
        $action[2](0);
        $action[4](0);

        printf("    addq %%%d, %d(%%rbp)\n", $2->val, $4->val);

        $0->val = $4->val;
        $0->valtype = meM;
    };


mem:    STORE(imm, mem)
    { $cost[0].cost=$cost[2].cost+$cost[3].cost+1; }
    = {
        $action[2](0);
        $action[3](0);

        printf("    movq $%d, %d(%%rbp)\n", $2->val, $3->val);

        $0->val = $3->val;
        $0->valtype = meM;
    };


mem:    STORE(reg, mem)
    { $cost[0].cost=$cost[2].cost+$cost[3].cost+1; }
    = {
        printf("processing store\n");
        $action[2](0);
        $action[3](0);

        printf("    movq %%%d, %d(%%rbp)\n", $2->val, $3->val);

        $0->val = $3->val;
        $0->valtype = meM;
    };

mem:    STORE(LOAD(mem), mem)
    { $cost[0].cost=$cost[3].cost+$cost[4].cost+1; }
    = {
        $action[3](0);
        $action[4](0);

        printf("    movq %d(%%rbp), %d(%%rbp)\n", $3->val, $4->val);

        $0->val = $4->val;
        $0->valtype = meM;
    };


mem:    OFFSET
    { $cost[0].cost=0; }
    = {
        return;
    };

arglist:    MERGE(reg, arglist)
    { $cost[0].cost=$cost[2].cost+$cost[3].cost+1; }
    = {
        printf("I'm there %d\n", RegCounter);
        $action[2](0);
        $action[3](0);

        if( $3->val < 7 )
            printf("    movq %%%d, %s\n", $2->val, ArgRegs[$3->val]);
        else
            printf("    movq %%%d, %d(%%rsp)\n", $2->val, 8*($3->val-6));

        $0->val = $3->val+1;
        $0->valtype = arglisT;
    };

arglist:    MERGE(LOAD(mem), arglist)
    { $cost[0].cost=$cost[3].cost+$cost[4].cost+1; }
    = {
        printf("I'm here %d\n", RegCounter);
        $action[3](0);
        $action[4](0);

        if( $4->val < 7 )
            printf("    movq %d(%%rbp), %s\n", $3->val, ArgRegs[$4->val]);
        else
            printf("    movq %d(%%rbp), %d(%%rsp)\n", $3->val, 8*($4->val-6));

        $0->val = $4->val+1;
        $0->valtype = arglisT;
 
    };

arglist:    MERGE(reg, argend)
    { $cost[0].cost=$cost[2].cost+$cost[3].cost+1; }
    = {
        $action[2](0);
        $action[3](0);

        printf("    movq %%%d, %s\n", $2->val, ArgRegs[0]);

        $0->val = 1;
        $0->valtype = arglisT;
    };

arglist:    MERGE(LOAD(mem), argend)
    { $cost[0].cost=$cost[3].cost+$cost[4].cost+1; }
    = {
        printf("This should be the end\n");
        $action[3](0);
        $action[4](0);

        printf("    movq %d(%%rbp), %s\n", $3->val, ArgRegs[0]);

        $0->val = 1;
        $0->valtype = arglisT;
    };

argend:     ARGEND
    { $cost[0].cost=0; }
    = {
        return;
    };

imm:    IMM
    { $cost[0].cost=0; }
    = {
        return;
    };

%%

/* burm_trace - print trace message for matching p */
static void burm_trace(NODEPTR p, int eruleno, COST cost) {
	if (shouldTrace)
		std::cerr << "0x" << p << " matched " << burm_string[eruleno] << " = " << eruleno << " with cost " << cost.cost << "\n";
}

static void gen(NODEPTR p) {
	if (burm_label(p) == 0)
		std::cerr << "no cover\n";
	else {
		stmt_action(p->x.state,0);
		if (shouldCover != 0)
			dumpCover(p, 1, 0);
	}
}

static Tree tree(int op, Tree l, Tree r) {
	Tree t = (Tree) malloc(sizeof *t);

	t->op = op;
	t->kids[0] = l; t->kids[1] = r;
	t->val = 0;
    t->valtype = nontypE;
	t->x.state = 0;
    t->I = 0;
	return t;
}
/*
int main(int argc, char *argv[]) {
	Tree t;
	int i;

	for (i = 1; i < argc ; ++i) {
		if (strcmp(argv[i], "--cover") == 0){
			shouldCover = 1;
		}
		if (strcmp(argv[i], "--trace") == 0){
			shouldTrace = 1;
		}
	}
	//printf("a = a + b;\n");

	Tree t0= (Tree) malloc(sizeof *t0);
	Tree t1= (Tree) malloc(sizeof *t1);
	Tree t2= (Tree) malloc(sizeof *t2);
	Tree t3= (Tree) malloc(sizeof *t3);

    t0 -> op = IMM;
    t0 -> val = 1;
    t0 ->kids[0] = 0;
    t0 ->kids[1] = 0;
	t0->x.state = 0;

    t1 -> op = IMM;
    t1 -> val = -;
    t1 ->kids[0] = 0;
    t1 ->kids[1] = 0;
	t1->x.state = 0;

    t2 -> op = IMM;
    t2 -> val = 2;
    t2 ->kids[0] = 0;
    t2 ->kids[1] = 0;
	t2->x.state = 0;

    t3 -> op = IMM;
    t3 -> val = -4;
    t3 ->kids[0] = 0;
    t3 ->kids[1] = 0;
	t3->x.state = 0;


	t = tree(ADD, 
             tree(LOAD,
                  tree(STORE, t0, t1 ),
                  0),
             tree(LOAD,
                  tree(STORE, t2, t3 ),
                  0)
		);
    Tree t5 = tree(RET,t,0);

    printf("    .text\n");

	gen(t5);

    printf("\n");
    printf("    .global main\n");
    printf("main:\n");
    printf("    push %%rbp\n");
    printf("    mov %%rsp, %%rbp\n");
    printf("    call _Your_main\n");
    printf("    mov %%rbp, %%rsp\n");
    printf("    pop %%rbp\n");
    printf("    ret\n");

    printf("\n");
    printf("    .data\n");
    // traverse the table for global value
    // for printf("g_%s: .qual 0\n", g->val);
	return 0;
}*/
